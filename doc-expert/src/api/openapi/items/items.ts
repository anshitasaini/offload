/**
 * Generated by orval v6.19.1 🍺
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import { useInfiniteQuery, useQuery } from "@tanstack/react-query"
import type {
  InfiniteData,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseQueryOptions,
  UseQueryResult
} from "@tanstack/react-query"

import { customAxios } from "../../client"
import type { ErrorType } from "../../client"
import type { HTTPValidationError, ItemsReadItemParams } from ".././schemas"

/**
 * @summary Read Item
 */
export const itemsReadItem = (
  itemId: number,
  params?: ItemsReadItemParams,
  signal?: AbortSignal
) => {
  return customAxios<unknown>({
    url: `/items/${itemId}`,
    method: "get",
    params,
    signal
  })
}

export const getItemsReadItemQueryKey = (
  itemId: number,
  params?: ItemsReadItemParams
) => {
  return [`/items/${itemId}`, ...(params ? [params] : [])] as const
}

export const getItemsReadItemInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemsReadItem>>,
    ItemsReadItemParams["cursor"]
  >,
  TError = ErrorType<HTTPValidationError>
>(
  itemId: number,
  params?: ItemsReadItemParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemsReadItem>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemsReadItem>>,
        QueryKey,
        ItemsReadItemParams["cursor"]
      >
    >
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getItemsReadItemQueryKey(itemId, params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemsReadItem>>,
    QueryKey,
    ItemsReadItemParams["cursor"]
  > = ({ signal, pageParam }) =>
    itemsReadItem(itemId, { cursor: pageParam, ...params }, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof itemsReadItem>>,
    TError,
    TData,
    Awaited<ReturnType<typeof itemsReadItem>>,
    QueryKey,
    ItemsReadItemParams["cursor"]
  > & { queryKey: QueryKey }
}

export type ItemsReadItemInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemsReadItem>>
>
export type ItemsReadItemInfiniteQueryError = ErrorType<HTTPValidationError>

/**
 * @summary Read Item
 */
export const useItemsReadItemInfinite = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemsReadItem>>,
    ItemsReadItemParams["cursor"]
  >,
  TError = ErrorType<HTTPValidationError>
>(
  itemId: number,
  params?: ItemsReadItemParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemsReadItem>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemsReadItem>>,
        QueryKey,
        ItemsReadItemParams["cursor"]
      >
    >
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getItemsReadItemInfiniteQueryOptions(
    itemId,
    params,
    options
  )

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getItemsReadItemQueryOptions = <
  TData = Awaited<ReturnType<typeof itemsReadItem>>,
  TError = ErrorType<HTTPValidationError>
>(
  itemId: number,
  params?: ItemsReadItemParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemsReadItem>>, TError, TData>
    >
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getItemsReadItemQueryKey(itemId, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof itemsReadItem>>> = ({
    signal
  }) => itemsReadItem(itemId, params, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!itemId,
    ...queryOptions
  } as UseQueryOptions<
    Awaited<ReturnType<typeof itemsReadItem>>,
    TError,
    TData
  > & { queryKey: QueryKey }
}

export type ItemsReadItemQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemsReadItem>>
>
export type ItemsReadItemQueryError = ErrorType<HTTPValidationError>

/**
 * @summary Read Item
 */
export const useItemsReadItem = <
  TData = Awaited<ReturnType<typeof itemsReadItem>>,
  TError = ErrorType<HTTPValidationError>
>(
  itemId: number,
  params?: ItemsReadItemParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemsReadItem>>, TError, TData>
    >
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getItemsReadItemQueryOptions(itemId, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}
